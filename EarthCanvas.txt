"use client";
import Sun from "./Sun";
import Earth from "./Earth";
import * as THREE from "three";
import Atmosphere from "./Atmosphere";
import { OrbitControls, Stars, useScroll } from "@react-three/drei";
import { Canvas } from "@react-three/fiber";
import { motion, useAnimationFrame } from "motion/react";
import GradientText from "@/src/components/GradientText";
import { useSpring, animated } from "@react-spring/three";
import AnimatedCameraLookAt from "./AnimatedCameraLookAt";
import React, { useMemo, useState, useEffect, useRef } from "react";

const EarthCanvas: React.FC = () => {
  //To check whether the screen is of small devices
  const isMobile = useMemo(() => {
    if (typeof window !== "undefined") {
      return window.innerWidth <= 1024;
    }
    return false;
  }, []);

  //Constant to Change the coordinates of camera lookAt
  const initialLookAtTarget: [number, number, number] = isMobile
    ? [1, 6, 1]
    : [1, 7, 1];
  //Constant to Change the scale of mesh
  const initialScaleTarget = isMobile ? 2.5 : 3.5;

  const [lookAtTarget, setLookAtTarget] =
    useState<[number, number, number]>(initialLookAtTarget);
  const [scaleTarget, setScaleTarget] = useState(initialScaleTarget);
  const [isChangingView, setIsChangingView] = useState(false);

  useAnimationFrame(() => {
    if (isChangingView) {
      const scaleRatio = (window.innerWidth / 786) * 0.75;
      const clampedScale = Math.min(Math.max(scaleRatio, 0.75), 1.5);
      setScaleTarget((prev) => (prev !== clampedScale ? clampedScale : prev));
    }
  });
  const handleAnimationComplete = () => {
    handleChangeView();
    console.log("End");
  };
  const handleChangeView = () => {
    setLookAtTarget([0, 0, 0]);
    setIsChangingView(true);
  };

  const { scale } = useSpring({
    scale: scaleTarget,
    config: { duration: 988, tension: 170, friction: 25 },
  });

  const sunDirection = useMemo(
    () => new THREE.Vector3(0, 0, 1).normalize(),
    [],
  );

  return (
    <>
      <div className="canvasMain">
        <div className="canva">
          <Canvas camera={{ position: [12, 5, 10], fov: 25 }}>
            <AnimatedCameraLookAt target={lookAtTarget} />
            <animated.mesh scale={scale}>
              {/* <Stars
                radius={1}
                depth={50}
                count={5000}
                factor={4}
                saturation={0}
                fade
                speed={0.5}
              /> */}
              <Earth sunDirection={sunDirection} />
              <Sun sunDirection={sunDirection} />
              <Atmosphere sunDirection={sunDirection} />
              <axesHelper args={[5]} />
            </animated.mesh>
          </Canvas>
        </div>
        <div className="Hello absolute top-0 items-center justify-start pl-[4vw] sm:justify-center">
          <div className="testing relative -top-[20%]">
            <motion.div
              initial={{ x: -100, opacity: 1 }}
              animate={{ x: 100, opacity: 0 }}
              transition={{ duration: 2, ease: "easeInOut", delay: 2 }}
              onAnimationComplete={handleAnimationComplete}
              className="loading"
            >
              {/* Testing */}
            </motion.div>
            <h1 className="text-left text-5xl font-semibold tracking-tight sm:text-center sm:text-4xl md:text-5xl lg:text-7xl">
              PROPELLING
              <br />
              <div className="flex flex-col justify-start gap-0 sm:flex-row sm:gap-[1.5vw]">
                <p>TO AND FOR THE</p>
                <GradientText
                  colors={[
                    "#40ffaa",
                    "#4079ff",
                    "#40ffaa",
                    "#4079ff",
                    "#40ffaa",
                  ]}
                  animationSpeed={6}
                  showBorder={false}
                  className="text-left text-5xl font-semibold tracking-tight sm:text-4xl md:text-5xl lg:text-7xl"
                >
                  BEYONDS
                </GradientText>
              </div>
            </h1>
          </div>
        </div>
        <div className="Hello">Hello</div>
      </div>
    </>
  );
};

export default EarthCanvas;

///

("use client");
import { OrbitControls, ScrollControls } from "@react-three/drei";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { useEffect, useMemo, useRef } from "react";
import * as THREE from "three";
import gsap from "gsap";
import Earth from "./Earth";
import ScrollTrigger from "gsap/ScrollTrigger";
import { useControls } from "leva";
import Sun from "./Sun";
import Atmosphere from "./Atmosphere";
gsap.registerPlugin(ScrollTrigger);

export default function Test() {
  const sunDirection = useMemo(
    () => new THREE.Vector3(0, 0, 1).normalize(),
    [],
  );

  return (
    <Canvas camera={{ position: [15, 0, 0], fov: 25 }}>
      <OrbitControls enableZoom={false} />
      <ScrollControls pages={0} damping={0.5}>
        <mesh scale={1.5}>
          <CameraController />
          <Earth sunDirection={sunDirection} />
          <Sun sunDirection={sunDirection} />
          <Atmosphere sunDirection={sunDirection} />
        </mesh>
      </ScrollControls>
    </Canvas>
  );
}

function CameraController() {
  const { scene, camera } = useThree();
  const isInitialized = useRef(false);

  // const { cameraPosition, scenePosition, sceneRotation } = useControls({
  //   cameraPosition: {
  //     value: { x: 15, y: 0, z: 0 },
  //   },
  //   scenePosition: { x: 7.5, y: -3, z: -3 },
  //   sceneRotation: { x: 0, y: 0, z: 0 },
  // });

  //useFrame(() => {
  // camera.position.x = cameraPosition.x;
  // camera.position.y = cameraPosition.y;
  // camera.position.z = cameraPosition.z;
  // scene.position.x = scenePosition.x;
  // scene.position.y = scenePosition.y;
  // scene.position.z = scenePosition.z;
  // scene.rotation.x = sceneRotation.x;
  // scene.rotation.y = sceneRotation.y;
  // scene.rotation.z = sceneRotation.z;
  //});
  useEffect(() => {
    console.log("Camera position before animation:", camera.position);
    console.log("Scene position before animation:", scene.position);
    if (!isInitialized.current) {
      console.log(scene.position);
      scene.position.set(7.5, -3, 0);
      isInitialized.current = true;
      console.log("Helloasd");
    }

    new ScrollTrigger({});
    gsap.to(scene.position, {
      x: 7.5,
      y: -2.5,
      z: -3,
      scrollTrigger: {
        trigger: ".second-section",
        start: "top bottom",
        end: "top top",
        scrub: true,
        immediateRender: false,
      },
      duration: 2,
      ease: "power2.inOut",
      onUpdate: () => camera.updateProjectionMatrix(),
      onComplete: () => {
        console.log(scene.position);
      },
    });

    gsap.to(scene.rotation, {
      x: 6,
      y: 0,
      z: 0,
      scrollTrigger: {
        trigger: ".second-section",
        start: "top bottom",
        end: "top top",
        scrub: true,
        immediateRender: false,
      },
      duration: 2,
      ease: "power2.inOut",
      onUpdate: () => camera.updateProjectionMatrix(),
    });
    gsap.to(scene.position, {
      x: 7.5,
      y: 0,
      z: -4,
      scrollTrigger: {
        trigger: ".third-section",
        start: "top bottom",
        end: "top top",
        scrub: true,
        immediateRender: false,
      },
      duration: 2,
      ease: "power2.inOut",
      onUpdate: () => camera.updateProjectionMatrix(),
    });

    gsap.to(scene.rotation, {
      x: 1.5,
      y: 0,
      z: 0,
      scrollTrigger: {
        trigger: ".third-section",
        start: "top bottom",
        end: "top top",
        scrub: true,
        immediateRender: false,
      },
      duration: 2,
      ease: "power2.inOut",
      onUpdate: () => camera.updateProjectionMatrix(),
    });
  }, [camera, scene]);

  return null;
}
